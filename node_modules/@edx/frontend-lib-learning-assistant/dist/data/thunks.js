"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.acknowledgeDisclosure = acknowledgeDisclosure;
exports.addChatMessage = addChatMessage;
exports.clearApiError = clearApiError;
exports.clearMessages = clearMessages;
exports.getChatResponse = getChatResponse;
exports.updateCurrentMessage = updateCurrentMessage;
exports.updateSidebarIsOpen = updateSidebarIsOpen;
var _analytics = require("@edx/frontend-platform/analytics");
var _auth = require("@edx/frontend-platform/auth");
var _api = _interopRequireDefault(require("./api"));
var _slice = require("./slice");
var _optimizelyExperiment = require("../utils/optimizelyExperiment");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function addChatMessage(role, content, courseId) {
  return (dispatch, getState) => {
    const {
      messageList,
      conversationId
    } = getState().learningAssistant;

    // Redux recommends only serializable values in the store, so we'll stringify the timestap to store in Redux.
    // When we need to operate on the Date object, we'll deserialize the string.
    const timestamp = new Date();
    const message = {
      role,
      content,
      timestamp: timestamp.toString()
    };
    const updatedMessageList = [...messageList, message];
    dispatch((0, _slice.setMessageList)({
      messageList: updatedMessageList
    }));
    dispatch((0, _slice.clearCurrentMessage)());
    dispatch((0, _slice.resetApiError)());
    const {
      userId
    } = (0, _auth.getAuthenticatedUser)();
    (0, _analytics.sendTrackEvent)('edx.ui.lms.learning_assistant.message', {
      id: conversationId,
      course_id: courseId,
      user_id: userId,
      timestamp: message.timestamp,
      role: message.role,
      content: message.content
    });
    if (message.role === 'user') {
      (0, _optimizelyExperiment.trackChatBotMessageOptimizely)(userId.toString());
    }
  };
}
function getChatResponse(courseId) {
  return async (dispatch, getState) => {
    const {
      messageList
    } = getState().learningAssistant;
    dispatch((0, _slice.setApiIsLoading)(true));
    try {
      const message = await (0, _api.default)(courseId, messageList);
      dispatch((0, _slice.setApiIsLoading)(false));
      dispatch(addChatMessage(message.role, message.content, courseId));
    } catch (error) {
      dispatch((0, _slice.setApiError)());
      dispatch((0, _slice.setApiIsLoading)(false));
    }
  };
}
function clearMessages() {
  return dispatch => {
    dispatch((0, _slice.resetMessages)());
    dispatch((0, _slice.resetApiError)());
  };
}
function updateCurrentMessage(content) {
  return dispatch => {
    dispatch((0, _slice.setCurrentMessage)({
      currentMessage: content
    }));
  };
}
function clearApiError() {
  return dispatch => {
    dispatch((0, _slice.resetApiError)());
  };
}
function acknowledgeDisclosure(isDisclosureAcknowledged) {
  return dispatch => {
    dispatch((0, _slice.setDisclosureAcknowledged)(isDisclosureAcknowledged));
  };
}
function updateSidebarIsOpen(isOpen) {
  return dispatch => {
    dispatch((0, _slice.setSidebarIsOpen)(isOpen));
  };
}
//# sourceMappingURL=thunks.js.map